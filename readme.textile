<html>
<head>
<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css" />
<script src="js/jquery-1.7.1.min.js"></script>
<script src="js/bootstrap-scrollspy.js"></script>
<script>
  $(function(){
    $('body').scrollspy({offset:40});
    $(".navbar ul li, .navbar ul li a").click(function(e){
      var anchor = $(e.target).attr("href"),
          offset = $(anchor).offset().top;
      $('body').scrollTop(offset-40);
      e.preventDefault();
    });
  })
</script>
<style>
  body{
    padding-top:40px;
  }
</style>
</head>
<body>
<div class="container">
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <ul class="nav">
        <li class="active"><a href="#overview">Overview</a></li>
        <li><a href="#types">Types</a></li>
        <li><a href="#length">Length</a></li>
        <li><a href="#string">Strings</a></li>
        <li><a href="#list">Lists</a></li>
        <li><a href="#set">Sets</a></li>
        <li><a href="#zset">Sorted Sets</a></li>
        <li><a href="#hash">Hashes</a></li>
        <li><a href="#ziplist">Ziplists</a></li>
        <li><a href="#intset">Intsets</a></li>
        <li><a href="#zipmap">Zipmaps</a></li>
      </ul>
    </div>
  </div>
</div>
h1=. RDB Spec

h2(#overview). Format layout

An rdb file begins with "REDIS0003" encoded as a bytestring. [9 bytes]

------

For each database in the dump

# The first byte is the SELECT_DB opcode (0xfe) [1 byte]
# The second byte is the length-encode database number (See below) [1-4 byte(s)]
# For each key-value pair in the database:
## If the object has an expire time:
## The first byte is the EXPIRETIME opcode (0xfd) or, in Redis 2.6+, EXPIRETIME_MS opcode (0xfc)
## What follows is the expire time in seconds or, in Redis 2.6+, in ms (See below)
# The first byte is the object type (See below for "list of object type opcodes":#types)
# Then, the string-encoded key for the object (See below)
# Then, the object itself, specially encoded for its type (See below)

------

An rdb file ends with the EOF opcode (0xff) [1 byte]

h2(#types). Object types

0x00 -> "String object":#string
0x01 -> "List object":#list
0x02 -> "Set object":#set
0x03 => "Sorted set object":#zset
0x04 -> "Hash object":#hash
0x09 -> "Zipmap":#zipmap
0x0a -> "Ziplist":#ziplist
0x0b -> "Intset":#inset
0x0c -> "Ziplist ==(as value-score pairs for a sorted set)==":#ziplist

h2(#length). Length-encoding

The first two most-significant bits hold the type of the value and the length

# The value is not specially encoded and has a length less than 64 (00)
# The value is not specially encoded and has a length less than 16,384 (01)
# The value is not specially encoded and has a length that fits in a 32-bit integer (10)
# The value is specially encoded (11)

The remaining bits hold the length (or, in the last case, encoding type) to be encoded (marked below as X's)

# (00) | XXXXXX [1 byte total]
# (01) | XXXXXX XXXXXXXX [2 bytes total]
# (10) | 000000 XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX [5 bytes total]
# (11) | XXXXXX [1 byte total] (The remaining 6 bits determine how the following value is encoded. This is unique to each type and will be described in the specific sections below on value types.)

h2(#string). String objects

The first 1-5 bytes of a string object contains the length of the string object and whether or not it is an encoded string, as described in the "length-encoding section above":#length .

If the string is not an encoded type, it is simply a series of n bytes where n is the length determined above.

If the string is an encoded type and the bottom two bits of the length are either (00,01,or 10), the string is loaded as an integer and converted to a string. Otherwise the string is lzf-decompressed and loaded as a string.
# If the bottom two bits of the length are set to 00, the string is a 8-bit signed integer
# If the bottom two bits of the length are set to 01, the string is a 16-bit signed integer
# If the bottom two bits of the length are set to 10, the string is a 32-bit signed integer
# If the bottom two bits of the length are set to 10, the string is "lzf-compressed":#lzf-compression

Example (the string "foo"):
[03] -> (00000011) The string is normally encoded as a series of 3 characters
[66 6f 6f] => "foo"

Example (the string "-1"):
[c0] -> (11000000) The string is an 8-bit signed integer
[ff] => "-1"

Example (the string "256"):
[c1] -> (11000001) The string is a 16-bit signed integer
[00 01] -> "256"

h2(#list). List objects

The first 1-5 bytes of a list object contains the number of list members, as described in the "length-encoding section above":#length .

There is no special encoding type for lists. Their compact representation is the "ziplist":#ziplist but this will be specified as the object type, not in the length encoding.

List objects are simply n strings, decoded as "string objects":#string where n is the length from above.

h2(#set). Set objects

The first 1-5 bytes of a set object contains the number of set members, as described in the "length-encoding section above":#length .

There is no special encoding type for lists. Their compact representation is the "intset":#intset but this will be specified as the object type, not in the length encoding. The intset is reserved for sets in which all members are integers.

Set objects are simply n strings, decoded as "string objects":#string where n is the length from above.

h2(#zset). Sorted set object

The first 1-5 bytes of a sorted set object contains the number of value-score pairs, as described in the "length-encoding section above":#length .

There is no special encoding type for sorted sets. Their compact representation is a "ziplist":#ziplist of value-score pairs but this will be specified as the object type, not in the length encoding.

Sorted Set objects are n value-score pairs. 

Each value is decoded as "string objects":#string where n is the length from above. 

Every value is followed by a double value specifying its score. This double should be decoded as "specified in the double section below":#double .

h2(#hash). Hash object

The first 1-5 bytes of a hash object contains the number of key-value pairs, as described in the "length-encoding section above":#length .

There is no special encoding type for hashes. Their compact representation is the "zipmap":#zipmap but this will be specified as the object type, not in the length encoding.

The rest of the hash is decoded as 2n "string objects":#string where n is the length from above.

Every other string is the key followed by the string representing its value.

h2(#ziplist). Ziplist

(Note: I was unable to find whether the endiannesses listed below as little-endian encodings were always litle-endian or whether they are stored as host byte order.)

Ziplists are space-efficient special encodings for lists and sorted sets. The max number of members and max size for the ziplist encoding is set in the conf file that the Redis server reads when starting.

The first 4 bytes store the number of bytes in the ziplist

The next 4 bytes store the offset (in bytes) to the end of the last entry in the list

The next 2 bytes store the number of members of the ziplist

The remaining n-1 bytes of the ziplist store a sequence of members. If the ziplist is encoding a sorted set, the members should be parsed as value, score pairs.

The structure of every ziplist member is as follows:

# First, is the number of bytes of the previous member in the ziplist. If this byte is less than 0xfe, the length is stored as a single byte. If the first byte is set to 0xfe, the next four bytes will hold the length of the previous member.
# Next, is the encoding and length of the current member of the ziplist. This is similar, though not exactly the same, to the way the lengths and encodings of RDB objects are stored.
## If the first two most-significant bits are set to zero (00), the ziplist member is encoded as an n-bytes long string where n is the value of the remaining 6 bits. (00|XXXXXX)
## If the first two most-significant bits are set to one (01), the ziplist member is encoded as an n-bytes long string where n is the conjunction of remaining 6 bits shifted left 8 bytes and the next byte (01|XXXXXX XXXXXXXX)
## If the first two most-significant bits are set to two (10), the ziplist member is encoded as an n-bytes long string where n is the conjunction of remaining 6 bits shifted left 16 bytes and the next two bytes (01|XXXXXX XXXXXXXX XXXXXXXX).
## If the first two most-significant bits are set to three and the next two bits are set to zero (1100), the ziplist member is encoded as an int16t (2 bytes).
## If the first two most-significant bits are set to three and the next two bits are set to one (1101), the ziplist member is encoded as an int32t (4 bytes).
## If the first two most-significant bits are set to three and the next two bits are set to two (1110), the ziplist member is encoded as an int64t (8 bytes).
# Finally, comes the value specified by the encoding and length

Every ziplist terminates with a 0xff byte

Example (encoding the very silly list [1,1]):

[13 00 00 00] -> Little-endian 32-bit length (in bytes) of ziplist

[0e 00 00 00] -> little-endian 32-bit offset (in bytes) to the end of the last entry in the list

[02 00]       -> little-endian 16-bit number of list entries

==[00]==          -> number of bytes of previous entry

[c0]          -> value encoding (11000000, which means a 16-bit signed integer follows)

[01 00]       -> 16-bit value 

==[04]==          -> number of bytes of previous entry

[c0]          -> value encoding (11000000, which means a 16-bit signed integer follows)

[01 00]       -> 16-bit value

[ff]          -> end of ziplist

h2(#intset). Intset

(Note: I was unable to find whether the endiannesses listed below as little-endian encodings were always litle-endian or whether they are stored as host byte order.)

The intset is used to encode sets consisting only of integers.

Intsets begin with a 32-bit length, specifying the length of each member of the intset.

Second, there is a 32-bit number specifying the number of elements in the intset

Finally, every member is a signed integer, the size of which is specified above.

Intsets end with a 0xff

Example (encoding the set [1,-1])

[02 00 00 00] -> Little-endian 32-bit length encoding, in bytes, of members of the intset (2, or 16-bits)

[02 00 00 00] -> Little-endian 32-bit number of elements in the intset (2)

[ff ff] -> One little-endian 16-bit member (-1 [signed int16])

[01 00] -> One little-endian 16-bit member

[ff] -> End of intset

h2(#zipmap). Zipmap

Zipmaps are space-efficient special encodings for hashes. The max number of members and max size for the zipmap encoding is set in the conf file that the Redis server reads when starting.

The first byte specifies the length of the zipmap. If the length of the zipmap is greater than or equal to 0xfe, disregard this length and traverse the entire zipmap until 0xff is encountered after a member.

Next is a series of key-value pairs encoded as follows:

# First, the length of key. If this value is less than 0xfd, this is the length of the key. A value of 0xfe indicates the length is encoded as the next 4 bytes in host-byte order.
# The next n bytes contain a bytestring of the key, where n is the length above.
# Next is the length of the value encoded in the same manner as the length of the key.
# Next is an 8-byte integer that specifies the number of free unused bytes after the string. When values are re-set from a longer value to a shorter value, some bytes may be set aside to make it faster to re-increase the size of the value. If you are parsing the structure, however, make sure you consume the free bytes are you consume the value. You can then disregard these free bytes.
# The next n bytes contain a bytestring of the value, where n is the length above.
# The next o bytes contain "free" bytes that should be thrown away, where o is the free length above.

The zipmap ends with a 0xff

Example (encoding the hash {bar: 1})

==[01]== -> The length of the zip-map (1 key-value pair)

==[03]== -> The length of the first key

[62 61 72] -> "bar" 

==[01]== -> The length of the first value

==[02]== -> Number of free bytes 

==[31]== -> "1"

[6e 65] -> 2 free bytes ("ne" from a previous setting of bar to "one". These can be thrown out) 

==[ff]== -> End of zipmap

h2(#lzf-compression). LZF Compression

The LZF compression is a fast, cousin of the more-popular LZW compression algorithm. 

The first 1-5 byte(s) are a "length-encoded":#length length of the compressed string.

The second 1-5 byte(s) are a "length-encoded":#length length of the decompressed string.

The next n bytes are in compressed lzf format, where n is the first length above.

To decompress LZF, use the following loop:
# Take one byte and divide it into the first three bits and the remaining five. (LLL | HHHHH)
# The first three bytes (LLL) will be a number between 0 and 7 and will be referred to as the "length".
# The remaining five bits specify what is called the "high distance"
## If the first three bits == 0x00, copy length+1 bytes from the compressed stream and append them to the current decompresses stream. Go to the beginning of this decompression loop and continue.
## If the first three bits > 0 && < 7, this is "length". Continue.
## If the first three bits == 7, fetch a new byte and add 7 to its value. This is the "length". Continue.
# Fetch another byte and add its value to the "high distance" 

</div>
</body>

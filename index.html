<html>
<head>
<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css" />
<script src="js/jquery-1.7.1.min.js"></script><script src="js/bootstrap-scrollspy.js"></script><script>
  $(function(){
    $('body').scrollspy({offset:40});
    $(".navbar ul li, .navbar ul li a").click(function(e){
      var anchor = $(e.target).attr("href"),
          offset = $(anchor).offset().top;
      $('body').scrollTop(offset-40);
      e.preventDefault();
    });
  })
</script><style>
body{
padding-top:40px;
}
</style>
</head>
<body>
<div class="container">
<div class="navbar navbar-fixed-top">
<div class="navbar-inner">
<div class="container">
<ul class="nav">
        <li class="active"><a href="#overview">Overview</a></li>
        <li><a href="#types">Types</a></li>
        <li><a href="#length">Length</a></li>
        <li><a href="#string">Strings</a></li>
        <li><a href="#list">Lists</a></li>
        <li><a href="#set">Sets</a></li>
        <li><a href="#zset">Sorted Sets</a></li>
        <li><a href="#hash">Hashes</a></li>
        <li><a href="#ziplist">Ziplists</a></li>
        <li><a href="#intset">Intsets</a></li>
        <li><a href="#zipmap">Zipmaps</a></li>
        <li><a href="#lzf-compression"><span class="caps">LZF</span></a></li>
</ul>
</div>
</div>
</div>
<h1 style="text-align:center;"><span class="caps">RDB</span> Spec</h1>
<h2 id="overview">Format layout</h2>
<p>An rdb file begins with &#8220;REDIS0003&#8221; encoded as a bytestring. [9 bytes]</p>
<hr />
<p>For each database in the dump</p>
<ol>
	<li>The first byte is the SELECT_DB opcode (0xfe) [1 byte]</li>
	<li>The second byte is the length-encode database number (See below) [1-4 byte(s)]</li>
	<li>For each key-value pair in the database:
	<ol>
		<li>If the object has an expire time:</li>
		<li>The first byte is the <span class="caps">EXPIRETIME</span> opcode (0xfd) or, in Redis 2.6+, EXPIRETIME_MS opcode (0xfc)</li>
		<li>What follows is the expire time in seconds or, in Redis 2.6+, in ms (See below)</li>
	</ol></li>
	<li>The first byte is the object type (See below for <a href="#types">list of object type opcodes</a>)</li>
	<li>Then, the string-encoded key for the object (See below)</li>
	<li>Then, the object itself, specially encoded for its type (See below)</li>
</ol>
<hr />
<p>An rdb file ends with the <span class="caps">EOF</span> opcode (0xff) [1 byte]</p>
<h2 id="types">Object types</h2>
<p>0&#215;00 &#8594; <a href="#string">String object</a><br />
0&#215;01 &#8594; <a href="#list">List object</a><br />
0&#215;02 &#8594; <a href="#set">Set object</a><br />
0&#215;03 =&gt; <a href="#zset">Sorted set object</a><br />
0&#215;04 &#8594; <a href="#hash">Hash object</a><br />
0&#215;09 &#8594; <a href="#zipmap">Zipmap</a><br />
0&#215;0a &#8594; <a href="#ziplist">Ziplist</a><br />
0&#215;0b &#8594; <a href="#inset">Intset</a><br />
0&#215;0c &#8594; <a href="#ziplist">Ziplist (as value-score pairs for a sorted set)</a></p>
<h2 id="length">Length-encoding</h2>
<p>The first two most-significant bits hold the type of the value and the length</p>
<ol>
	<li>The value is not specially encoded and has a length less than 64 (00)</li>
	<li>The value is not specially encoded and has a length less than 16,384 (01)</li>
	<li>The value is not specially encoded and has a length that fits in a 32-bit integer (10)</li>
	<li>The value is specially encoded (11)</li>
</ol>
<p>The remaining bits hold the length (or, in the last case, encoding type) to be encoded (marked below as X&#8217;s)</p>
<ol>
	<li>(00) | <span class="caps">XXXXXX</span> [1 byte total]</li>
	<li>(01) | <span class="caps">XXXXXX</span> <span class="caps">XXXXXXXX</span> [2 bytes total]</li>
	<li>(10) | 000000 <span class="caps">XXXXXXXX</span> <span class="caps">XXXXXXXX</span> <span class="caps">XXXXXXXX</span> <span class="caps">XXXXXXXX</span> [5 bytes total]</li>
	<li>(11) | <span class="caps">XXXXXX</span> [1 byte total] (The remaining 6 bits determine how the following value is encoded. This is unique to each type and will be described in the specific sections below on value types.)</li>
</ol>
<h2 id="string">String objects</h2>
<p>The first 1-5 bytes of a string object contains the length of the string object and whether or not it is an encoded string, as described in the <a href="#length">length-encoding section above</a> .</p>
<p>If the string is not an encoded type, it is simply a series of n bytes where n is the length determined above.</p>
<p>If the string is an encoded type and the bottom two bits of the length are either (00,01,or 10), the string is loaded as an integer and converted to a string. Otherwise the string is lzf-decompressed and loaded as a string.</p>
<ol>
	<li>If the bottom two bits of the length are set to 00, the string is a 8-bit signed integer</li>
	<li>If the bottom two bits of the length are set to 01, the string is a 16-bit signed integer</li>
	<li>If the bottom two bits of the length are set to 10, the string is a 32-bit signed integer</li>
	<li>If the bottom two bits of the length are set to 10, the string is <a href="#lzf-compression">lzf-compressed</a></li>
</ol>
<p>Example (the string &#8220;foo&#8221;):<br />
<sup class="footnote" id="fnr03"><a href="#fn03">03</a></sup> &#8594; (00000011) The string is normally encoded as a series of 3 characters<br />
[66 6f 6f] =&gt; &#8220;foo&#8221;</p>
<p>Example (the string &#8220;-1&#8221;):<br />
[c0] &#8594; (11000000) The string is an 8-bit signed integer<br />
[ff] =&gt; &#8220;-1&#8221;</p>
<p>Example (the string &#8220;256&#8221;):<br />
[c1] &#8594; (11000001) The string is a 16-bit signed integer<br />
[00 01] &#8594; &#8220;256&#8221;</p>
<h2 id="list">List objects</h2>
<p>The first 1-5 bytes of a list object contains the number of list members, as described in the <a href="#length">length-encoding section above</a> .</p>
<p>There is no special encoding type for lists. Their compact representation is the <a href="#ziplist">ziplist</a> but this will be specified as the object type, not in the length encoding.</p>
<p>List objects are simply n strings, decoded as <a href="#string">string objects</a> where n is the length from above.</p>
<h2 id="set">Set objects</h2>
<p>The first 1-5 bytes of a set object contains the number of set members, as described in the <a href="#length">length-encoding section above</a> .</p>
<p>There is no special encoding type for lists. Their compact representation is the <a href="#intset">intset</a> but this will be specified as the object type, not in the length encoding. The intset is reserved for sets in which all members are integers.</p>
<p>Set objects are simply n strings, decoded as <a href="#string">string objects</a> where n is the length from above.</p>
<h2 id="zset">Sorted set object</h2>
<p>The first 1-5 bytes of a sorted set object contains the number of value-score pairs, as described in the <a href="#length">length-encoding section above</a> .</p>
<p>There is no special encoding type for sorted sets. Their compact representation is a <a href="#ziplist">ziplist</a> of value-score pairs but this will be specified as the object type, not in the length encoding.</p>
<p>Sorted Set objects are n value-score pairs.</p>
<p>Each value is decoded as <a href="#string">string objects</a> where n is the length from above.</p>
<p>Every value is followed by a double value specifying its score. This double should be decoded as <a href="#double">specified in the double section below</a> .</p>
<h2 id="hash">Hash object</h2>
<p>The first 1-5 bytes of a hash object contains the number of key-value pairs, as described in the <a href="#length">length-encoding section above</a> .</p>
<p>There is no special encoding type for hashes. Their compact representation is the <a href="#zipmap">zipmap</a> but this will be specified as the object type, not in the length encoding.</p>
<p>The rest of the hash is decoded as 2n <a href="#string">string objects</a> where n is the length from above.</p>
<p>Every other string is the key followed by the string representing its value.</p>
<h2 id="ziplist">Ziplist</h2>
<p>(Note: I was unable to find whether the endiannesses listed below as little-endian encodings were always litle-endian or whether they are stored as host byte order.)</p>
<p>Ziplists are space-efficient special encodings for lists and sorted sets. The max number of members and max size for the ziplist encoding is set in the conf file that the Redis server reads when starting.</p>
<p>The first 4 bytes store the number of bytes in the ziplist</p>
<p>The next 4 bytes store the offset (in bytes) to the end of the last entry in the list</p>
<p>The next 2 bytes store the number of members of the ziplist</p>
<p>The remaining n-1 bytes of the ziplist store a sequence of members. If the ziplist is encoding a sorted set, the members should be parsed as value, score pairs.</p>
<p>The structure of every ziplist member is as follows:</p>
<ol>
	<li>First, is the number of bytes of the previous member in the ziplist. If this byte is less than 0xfe, the length is stored as a single byte. If the first byte is set to 0xfe, the next four bytes will hold the length of the previous member.</li>
	<li>Next, is the encoding and length of the current member of the ziplist. This is similar, though not exactly the same, to the way the lengths and encodings of <span class="caps">RDB</span> objects are stored.
	<ol>
		<li>If the first two most-significant bits are set to zero (00), the ziplist member is encoded as an n-bytes long string where n is the value of the remaining 6 bits. (00|<span class="caps">XXXXXX</span>)</li>
		<li>If the first two most-significant bits are set to one (01), the ziplist member is encoded as an n-bytes long string where n is the conjunction of remaining 6 bits shifted left 8 bytes and the next byte (01|<span class="caps">XXXXXX</span> <span class="caps">XXXXXXXX</span>)</li>
		<li>If the first two most-significant bits are set to two (10), the ziplist member is encoded as an n-bytes long string where n is the conjunction of remaining 6 bits shifted left 16 bytes and the next two bytes (01|<span class="caps">XXXXXX</span> <span class="caps">XXXXXXXX</span> <span class="caps">XXXXXXXX</span>).</li>
		<li>If the first two most-significant bits are set to three and the next two bits are set to zero (1100), the ziplist member is encoded as an int16t (2 bytes).</li>
		<li>If the first two most-significant bits are set to three and the next two bits are set to one (1101), the ziplist member is encoded as an int32t (4 bytes).</li>
		<li>If the first two most-significant bits are set to three and the next two bits are set to two (1110), the ziplist member is encoded as an int64t (8 bytes).</li>
	</ol></li>
	<li>Finally, comes the value specified by the encoding and length</li>
</ol>
<p>Every ziplist terminates with a 0xff byte</p>
<p>Example (encoding the very silly list [1,1]):</p>
<p>[13 00 00 00] &#8594; Little-endian 32-bit length (in bytes) of ziplist</p>
<p>[0e 00 00 00] &#8594; little-endian 32-bit offset (in bytes) to the end of the last entry in the list</p>
<p>[02 00]       &#8594; little-endian 16-bit number of list entries</p>
<p>[00]          &#8594; number of bytes of previous entry</p>
<p>[c0]          &#8594; value encoding (11000000, which means a 16-bit signed integer follows)</p>
<p>[01 00]       &#8594; 16-bit value</p>
<p>[04]          &#8594; number of bytes of previous entry</p>
<p>[c0]          &#8594; value encoding (11000000, which means a 16-bit signed integer follows)</p>
<p>[01 00]       &#8594; 16-bit value</p>
<p>[ff]          &#8594; end of ziplist</p>
<h2 id="intset">Intset</h2>
<p>(Note: I was unable to find whether the endiannesses listed below as little-endian encodings were always litle-endian or whether they are stored as host byte order.)</p>
<p>The intset is used to encode sets consisting only of integers.</p>
<p>Intsets begin with a 32-bit length, specifying the length of each member of the intset.</p>
<p>Second, there is a 32-bit number specifying the number of elements in the intset</p>
<p>Finally, every member is a signed integer, the size of which is specified above.</p>
<p>Intsets end with a 0xff</p>
<p>Example (encoding the set [1,-1])</p>
<p>[02 00 00 00] &#8594; Little-endian 32-bit length encoding, in bytes, of members of the intset (2, or 16-bits)</p>
<p>[02 00 00 00] &#8594; Little-endian 32-bit number of elements in the intset (2)</p>
<p>[ff ff] &#8594; One little-endian 16-bit member (-1 [signed int16])</p>
<p>[01 00] &#8594; One little-endian 16-bit member</p>
<p>[ff] &#8594; End of intset</p>
<h2 id="zipmap">Zipmap</h2>
<p>Zipmaps are space-efficient special encodings for hashes. The max number of members and max size for the zipmap encoding is set in the conf file that the Redis server reads when starting.</p>
<p>The first byte specifies the length of the zipmap. If the length of the zipmap is greater than or equal to 0xfe, disregard this length and traverse the entire zipmap until 0xff is encountered after a member.</p>
<p>Next is a series of key-value pairs encoded as follows:</p>
<ol>
	<li>First, the length of key. If this value is less than 0xfd, this is the length of the key. A value of 0xfe indicates the length is encoded as the next 4 bytes in host-byte order.</li>
	<li>The next n bytes contain a bytestring of the key, where n is the length above.</li>
	<li>Next is the length of the value encoded in the same manner as the length of the key.</li>
	<li>Next is an 8-byte integer that specifies the number of free unused bytes after the string. When values are re-set from a longer value to a shorter value, some bytes may be set aside to make it faster to re-increase the size of the value. If you are parsing the structure, however, make sure you consume the free bytes are you consume the value. You can then disregard these free bytes.</li>
	<li>The next n bytes contain a bytestring of the value, where n is the length above.</li>
	<li>The next o bytes contain &#8220;free&#8221; bytes that should be thrown away, where o is the free length above.</li>
</ol>
<p>The zipmap ends with a 0xff</p>
<p>Example (encoding the hash {bar: 1})</p>
<p>[01] &#8594; The length of the zip-map (1 key-value pair)</p>
<p>[03] &#8594; The length of the first key</p>
<p>[62 61 72] &#8594; &#8220;bar&#8221;</p>
<p>[01] &#8594; The length of the first value</p>
<p>[02] &#8594; Number of free bytes</p>
<p>[31] &#8594; &#8220;1&#8221;</p>
<p>[6e 65] &#8594; 2 free bytes (&#8220;ne&#8221; from a previous setting of bar to &#8220;one&#8221;. These can be thrown out)</p>
<p>[ff] &#8594; End of zipmap</p>
<h2 id="lzf-compression"><span class="caps">LZF</span> Compression</h2>
<p>The <span class="caps">LZF</span> compression is a fast, cousin of the more-popular <span class="caps">LZW</span> compression algorithm.</p>
<p>The first 1-5 byte(s) are a <a href="#length">length-encoded</a> length of the compressed string.</p>
<p>The second 1-5 byte(s) are a <a href="#length">length-encoded</a> length of the decompressed string.</p>
<p>The next n bytes are in compressed lzf format, where n is the first length above.</p>
<p>To decompress <span class="caps">LZF</span>, use the following loop:</p>
<ol>
	<li>Take one byte and divide it into the first three bits and the remaining five. (<span class="caps">LLL</span> | <span class="caps">HHHHH</span>)</li>
	<li>The first three bytes (<span class="caps">LLL</span>) will be a number between 0 and 7 and will be referred to as the &#8220;length&#8221;.</li>
	<li>The remaining five bits specify what is called the &#8220;high distance&#8221;
	<ol>
		<li>If the first three bits == 0&#215;00, copy length+1 bytes from the compressed stream and append them to the current decompresses stream. Go to the beginning of this decompression loop and continue.</li>
		<li>If the first three bits &gt; 0 &amp;&amp; &lt; 7, this is &#8220;length&#8221;. Continue.</li>
		<li>If the first three bits == 7, fetch a new byte and add 7 to its value. This is the &#8220;length&#8221;. Continue.</li>
	</ol></li>
	<li>Fetch another byte and combine it with the &#8220;high distance.&#8221; (Shift the high distance left 8 bits and OR the two). This new value is the &#8220;distance&#8221;</li>
	<li>Now go to the [distance] to last char in the decoded string and copy [length]+2 characters. If length is longer than the remaining characters in the decoded string, loop back to the beginning of distance and continue copying.
	<ol>
		<li>For instance. If you have decoded &#8220;foobar&#8221; so far, your distance is 1 and your length+2 is 10, you would repeat &#8220;ar&#8221; five times, totalling 10 characters.</li>
	</ol></li>
	<li>Repeat this algorithm until you have reached the end of the compressed string.</li>
</ol>
<p>Example (encoded string &#8220;if i never if i never if i never&#8221;)</p>
<p>[12] &#8594; The compressed length is 18 bytes<br />
[20] &#8594; The original length is 32 bytes <br />
[0b] &#8594; (000 | 01011) Copy the next 11+1 bytes literally<br />
[69 66 20 69 20 6e 65 76 65 72 20 69] &#8594; &#8220;if i never i&#8221;<br />
[e0 0a] &#8594; (111 | 00000) (10) Set length to 10+7.<br />
[0a] &#8594; (10) Set distance to (00000 00001010) or 10. We move to the 10th to last character in &#8220;if i never i&#8221;. This is &#8216;f&#8217;. (&#8220;i&#8221; is the 0th character). Now copy 10+7+2 characters. There are only 11 characters to copy so we will copy those 11 characters, move back to &#8216;f&#8217; and copy 8 more. Our decoded string now reads &#8220;if i never if i never if i neve&#8221;<br />
[00] &#8594; (000 | 00000) Copy the next 0+1 byte literally<br />
[72] &#8594;&#174; &#8220;if i never if i never if i never&#8221;</p>
</div>
</body>
